<html><head><title>Geo::Index</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.35,
  using Pod::Simple::PullParser v3.35,
  under Perl v5.010001 at Sat Mar 30 11:45:39 2019 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<h1><a class='u'
name="Geo::Index"
>Geo::Index</a></h1>

<p>Section: User Contributed Perl Documentation (3)</p>

<h1><a class='u'
name="NAME"
>NAME</a></h1>

<p>Geo::Index - Geographic indexer</p>

<h1><a class='u'
name="VERSION"
>VERSION</a></h1>

<p>This document describes Geo::Index version 0.1.0</p>

<h1><a class='u'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  # Create and populate a geographic index
  
  use Geo::Index;
  
  my @points = (
                 { lat =&#62;   1.0, lon =&#62;   2.0 },
                 { lat =&#62; -90.0, lon =&#62;   0.0, name =&#62; &#39;South Pole&#39; },
                 { lat =&#62;  30.0, lon =&#62; -20.0, ele =&#62; 123.4 }
               );
  my $point = { lat=&#62;10.0, lon=&#62;20.0 };
  
  my $index = Geo::Index-&#62;new();
  $index-&#62;IndexPoints( \@points );
  $index-&#62;Index( $point );
  $index-&#62;Index( [ 30, 40 ] );
  
  
  # Search index
  
  my %search_options = ( sort_results =&#62; 1, radius=&#62;5_000_000 );
  my $results = $index-&#62;Search( [ -80, 20 ], \%search_options );
  print &#34;$$results[0]{name}\n&#34;;  # Prints &#39;South Pole&#39;
  
  # Get all points in the southern hemisphere
  my $results = $index-&#62;SearchByBounds( [ -180, -90, 180, 0 ] );
  print &#34;$$results[0]{name}\n&#34;;  # Also prints &#39;South Pole&#39;
  
  my ($closest) = $index-&#62;Closest( [ -80, 20 ] );
  print &#34;$$closest{name}\n&#34;;     # Also prints &#39;South Pole&#39;
  
  my ($farthest) = $index-&#62;Farthest( [ 90, 0 ] );
  print &#34;$$farthest{name}\n&#34;;    # Also prints &#39;South Pole&#39;
  
  
  # Compute distance in meters between two points (using haversine formula)
  
  my $m = $index-&#62;Distance( { lat=&#62;51.507222, lon=&#62;-0.1275 }, [ -6.2, 106.816667 ] );
  printf(&#34;London to Jakarta: %i km\n&#34;, $m / 1000);
  
  $index-&#62;DistanceFrom( [ 90, 0 ] );
  my $m = $index-&#62;DistanceTo( $points[1] );
  printf(&#34;Pole to pole:      %i km\n&#34;, $m / 1000);</pre>

<h1><a class='u'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Geo::Index allows the creation of in-memory geographic indices of sets of points. Once an index has been created one can run fast searches against it.</p>

<p>Efficient searches can be performed using <b><code>Search(...)</code></b> to get all points within a distance from a given point, <b><code>SearchByBounds(...)</code></b> to get all points in an given area, <b><code>Closest(...)</code></b> to get the closest points to a given point, and <b><code>Farthest(...)</code></b> to get the farthest points from a given point.</p>

<p>Additional methods are provided to compute distances between arbitrary points (&#160;<b><code>Distance(...)</code></b>, <b><code>DistanceFrom(...)</code></b>, and <b><code>DistanceTo(...)</code></b>&#160;) and to get the size in meters of one degree or the size in degrees of one meter at a given point (<b><code>OneDegreeInMeters(...)</code></b> and <b><code>OneMeterInDegrees(...)</code></b>, respectively).</p>

<p>While by default computations are done for the Earth, other bodies can be used by supplying appropriates radii and circumferences to <b><code>new(...)</code></b>.</p>

<h1><a class='u'
name="POINTS"
>POINTS</a></h1>

<p>Geo::Index works with points on a spherical body. Points are hash references containing, at a minimum, <code>lat</code> and <code>lon</code> entries which give the point&#39;s position in degrees. Additional hash entries can be present and will be both ignored and preserved. The <code>Index(...)</code>, <code>IndexPoints(...)</code>, <code>Search(...)</code>, <code>Closest(...)</code>, <code>Farthest(...)</code>, <code>Distance(...)</code>, <code>DistanceFrom(...)</code>, and <code>DistanceTo(...)</code> methods add additional entries in point hashes.</p>

<p>The hash entries used by Geo::Gpx are shown below. Apart from <code>lat</code> and <code>lon</code> these values are created by Geo::Gpx. Unless noted, these values may be read but should not be set, altered, or deleted.</p>

<ul>
<li><code>lat</code> - Point&#39;s latitude in degrees [ -90 .. 90 ]</li>

<li><code>lon</code> - Point longitude in degrees [ -180 .. 180 )
<p>These two values may be changed but the altered point should then be re-indexed using <code>Index(...)</code> before further searches are run.</p>
</li>

<li><code>data</code> - The optional user data supplied when a point was created using the array shorthand. This contents of this field may be freely modified by the user. See <code>Index(...)</code> and <code>IndexPoints(...)</code>, below.</li>

<li><code>lat_rad</code> - The point&#39;s latitude in radians [ -pi/2 .. pi/2 ]</li>

<li><code>lon_rad</code> - The point&#39;s longitude in radians [ -pi .. pi )</li>

<li><code>circumference</code> - Circumference (in meters) of the circle of latitude that the point falls on. This is computed from the body&#39;s equatorial circumference assuming a spherical (not an oblate) body.</li>

<li><code>search_result_distance</code> - Distance (in meters) of point from search point of previous search. The distance computation assumes a spherical body and is computed using a ruggedized version of the haversine formula. This value is only generated when <code>Search(...)</code> is called with the <code>radius</code> or <code>sort_results</code> option. See also <code>Distance(...)</code>, <code>DistanceFrom(...)</code>, and <code>DistanceTo(...)</code>.</li>

<li><code>antipode_distance</code> - Distance (in meters) of point from search point&#39;s antipode as determined by a previous call to <code>Farthest(...)</code>. This distance is computed using a ruggedized version of the haversine formula.</li>
</ul>

<p>As a convenience, most methods allow points to be specified using a shorthand notation <code>[&#160;<i>lat</i>,&#160;<i>lon</i>&#160;]</code> or <code>[&#160;<i>lat</i>,&#160;<i>lon</i>,&#160;<i>data</i>&#160;]</code>. Points given in this notation will be converted to hash-based points. If a point created using this notation is returned as a search result it will be as a reference to the hash constructed by Geo::Index and not as a reference to the original array. To access the data field of a point created using the shorthand notation use <code>$$point{&#39;data&#39;}</code> where <code>$point</code> is a search result point.</p>

<h1><a class='u'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u'
name="Geo::Index-&#62;new(_..._)"
>Geo::Index-&#62;new( ... )</a></h2>

<blockquote>
<p><code>$index = Geo::Index-&#62;new()</code>;</p>

<blockquote>
<p>Create a new empty index using default options: radius and circumferences are those of Earth, <code>levels</code> is set to 20 (~40&#160;m index resolution).</p>
</blockquote>

<p><code>$index = Geo::Index-&#62;new( \@points );</code></p>

<blockquote>
<p>Create a new index using default options and populate it with the given points.</p>

<p>The points in the array can be in either hash or array notation.</p>
</blockquote>

<p><code>$index = Geo::Index-&#62;new( \%options );</code></p>

<blockquote>
<p>Create a new empty index using specified options.</p>
</blockquote>

<p><code>$index = Geo::Index-&#62;new( \@points, \%options );</code></p>

<blockquote>
<p>Create a new index using specified options and populate it with the given points.</p>

<p>The points in the array can be in either hash or array notation.</p>
</blockquote>

<p><b>The options hash:</b></p>

<p>When a Geo::Index object is created, one can specify various options to fine-tune its behavior. The default values are suitable for a high-resolution index of Earth.</p>

<blockquote>
<p><b><code>radius</code></b></p>

<blockquote>
<p>Average planetary radius (in meters). (default:&#160;6371230)</p>

<p>If a <code>radius</code> is specified but <code>polar_circumference</code> or <code>equatorial_circumference</code> are not given then they will be calculated from the radius ( 2 * pi * radius )</p>
</blockquote>

<p><b><code>polar_circumference</code></b></p>

<blockquote>
<p>Polar (meridional) circumference of the object the points lie on (in meters). (default:&#160;40007863)</p>
</blockquote>

<p><b><code>equatorial_circumference</code></b></p>

<blockquote>
<p>Circumference at the equator of the object the points lie on (in meters). (default:&#160;40075017)</p>
</blockquote>

<p><b><code>levels</code></b></p>

<blockquote>
<p>Depth of index. (valid:&#160;&#62;0,&#160;&#60;30;&#160;default:&#160;20)</p>

<p>Note that the <code>levels</code> parameter specefies the number of non-full-globe index levels to generate and NOT the deepest index level. (Level -1, covering the entire globe, is always generated) For example, setting <code>levels</code> to 20 generates indices at levels 0 through 19 (plus level -1).</p>

<p>A summary of typical tile levels is shown below. To choose a value for the <code>levels</code> option using the table add 1 to the &#39;Level&#39; shown for the desired maximum level of detail. The &#39;Grid&#39; column shows the north-south size of each tile in meters at a each level. The &#39;Size&#39; column shows the initial amount of RAM needed for an indexed set of 1&#160;million random points using numeric keys on a 64-bit system when that level is the most detailed one (sizes may grow moderately once searches are run).</p>

<pre> Level    Grid      Size              Level   Grid     Size  
 -----  ---------  ---------------    -----  -------  -------
  -1    ~40000 km  (entire planet)     12      ~5 km  ~2.4 GB
   0    ~20000 km                      13    ~2.5 km  ~2.7 GB
   1    ~10000 km  ~1.0 GB             14    ~1.2 km  ~3.1 GB
   2     ~5000 km  ~1.0 GB             15    ~600 m   ~3.3 GB
   3     ~2500 km  ~1.1 GB             16    ~300 m   ~3.6 GB
   4     ~1250 km  ~1.2 GB             17    ~150 m   ~3.8 GB
   5      ~625 km  ~1.3 GB             18     ~75 m   ~4.1 GB
   6      ~315 km  ~1.4 GB             19     ~40 m   ~4.4 GB
   7      ~155 km  ~1.5 GB             20     ~20 m   ~4.6 GB
   8       ~80 km  ~1.6 GB             21     ~10 m   ~4.9 GB
   9       ~40 km  ~1.7 GB             22      ~5 m   ~5.1 GB
  10       ~20 km  ~1.9 GB             23      ~2 m   ~5.4 GB
  11       ~10 km  ~2.1 GB             24      ~1 m   ~5.6 GB</pre>

<p>For reference, the memory usage of the array of 1&#160;million random, unindexed points is about 440&#160;MB, growing to about 540&#160;MB with index use (about 100 bytes per point); the former amount is included in the index memory usage shown above.</p>
</blockquote>

<p><b><code>function_type</code></b></p>

<blockquote>
<p>Choose the type of low-level functions to use. (default:&#160;&#39;<code>double</code>&#39;&#160;if&#160;available,&#160;&#39;<code>perl</code>&#39;&#160;otherwise)</p>

<p>Geo::Index will attempt to use compiled C code to speed up certain calculations. If the compilation fails then equivalent (but slower) Perl code will be used.</p>

<p>This option can be used to explictly request the type of code to use. When set to &#39;<code>float</code>&#39; then compiled C code using single-precision floating point will be requested. When set to &#39;<code>double</code>&#39; then compiled C code using double-precision floating point will be requested. When set to &#39;<code>perl</code>&#39; then Perl code will be used. If compilation failed then Perl code will be used regardless of what was requested.</p>

<p>Perl natively uses double-precision floating point. On modern hardware double-precision is slightly faster than single-precision. On certain platforms, however, it may be preferable to use single-precision instead of double-precision floating point. When needed, using single-precision should not be an issue since the minor errors introduced from loss of precision are drowned out by the errors inherent in the haversine function that is used for distance calculations.</p>

<p>Geo::Index uses Inline::C to compile code.</p>

<p>If you are running in a server environment and want to use the accelerated C functions but do not want Inline::C to be able to write files to your script&#39;s working directory then there are two options available:</p>

<ul>
<li><b>Pre-build the C code</b>
<p>To do this log in to the server as yourself (or another user as appropriate) then <code>cd</code> to the script&#39;s working directory. Next, run the following command:</p>

<pre> perl -e &#34;use Geo::Index;&#34;</pre>

<p>The C code should automatically be compiled and stored in the <code>_Inline</code> subdirectory. Once this has been done, change permissions and/or ownership of the <code>_Inline</code> subdirectory and its contents to suit your liking. A simple <code>chmod&#160;-w&#160;-R&#160;_Inline</code> might suffice.</p>
</li>

<li><b>Specify a build and library directory</b>
<p>If you want to use the compiled C functions but don&#39;t want the build to be done in the current directory, you can specify an alternate build and library directory here. The example below creates <code>build</code> and <code>lib</code> directories along with a <code>config</code> file in <code>/tmp/</code>. For your own scripts, change <code>/tmp</code> as appropriate for your environment. The following should appear near the top of your script:</p>

<pre>    # Specify the build and library directory
    use Inline(Config =&#62; DIRECTORY =&#62; &#39;/tmp&#39;);
    
    # Load the module
    use Geo::Index;</pre>

<p>An example of doing this can be found in <code>examples/inline_c_directory.pl</code></p>

<p><b>Important: </b>The specified directory must exist and be writable before the script is run.</p>

<p><b>Important: </b>The lines MUST appear in the order shown.</p>
</li>
</ul>
</blockquote>
</blockquote>
</blockquote>

<h2><a class='u'
name="IndexPoints(_..._)"
>IndexPoints( ... )</a></h2>

<blockquote>
<p><code>$index-&#62;IndexPoints( \@points );</code></p>

<p>Add points in list to the index</p>

<p>If a point is added that already exists in the index and its position has changed then the exisiting index entry will be deleted and the point will be indexed again. If its position has not changed then no action will be taken.</p>

<p><b><code>@points</code></b></p>

<blockquote>
<p>The points to add to the index</p>

<p>Each point in the list is either a reference to a hash containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or a reference to an array giving the point. See the <b>POINTS</b> section above for details.</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="Index(_..._)"
>Index( ... )</a></h2>

<blockquote>
<p><code>$index-&#62;Index( \%point );</code></p>

<p><code>$index-&#62;Index( \@point );</code></p>

<p>Add a single point to the index</p>

<p>If the point being added already exists in the index and its position has changed then the exisiting index entry will be deleted and the point will be indexed again. If its position has not changed then no action will be taken.</p>

<p><b><code>%point</code></b> or <b><code>@point</code></b></p>

<blockquote>
<p>The point to add to the index</p>

<p>This can be either a hash containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or an array giving the point. See the <b>POINTS</b> section above for details.</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="DeletePointIndex(_..._)"
>DeletePointIndex( ... )</a></h2>

<blockquote>
<p><code>$index-&#62;DeletePointIndex( \%point );</code></p>

<p>Delete specified point from index</p>

<p>This method will remove the point from the index but will not destroy the actual point.</p>

<p><b><code>%point</code></b></p>

<blockquote>
<p>The point to delete.</p>

<p>Note that this must be a reference to the actual point to delete and not to a copy of it. Simply specifying a point&#39;s location as a new point hash will not work.</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="Search(_..._)"
>Search( ... )</a></h2>

<blockquote>
<p><code>@results = $index-&#62;Search( \%point, \%options );</code></p>

<p><code>$results_ref = $index-&#62;Search( \%point, \%options );</code></p>

<p>Search index for points near a given point</p>

<p><b><code>%point</code></b></p>

<blockquote>
<p>The point to search near</p>

<p>This is either a reference to a hash containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or a reference to an array giving the point. See the <b>POINTS</b> section above for details.</p>
</blockquote>

<p><b><code>%options</code></b></p>

<blockquote>
<p>The parameters for the search (all are optional):</p>

<p>Note that except for <code>radius</code>, none of the below options have any effect when <code>quick_results</code> is specified.</p>

<p><b><code>radius</code></b></p>

<blockquote>
<p>Only return results within this distance (in meters) from search point.</p>

<p>If no <code>radius</code> is specified or the <code>radius</code> is set to <code>Geo::Index::ALL</code> then all points in the index will be returned.</p>

<p>When <code>quick_results</code> is specified then all points within the specified radius will be returned (additional points outside the radius may also be returned).</p>
</blockquote>

<p><b><code>sort_results</code></b></p>

<blockquote>
<p>Sort results by distance from search point before filtering and returning them.</p>
</blockquote>

<p><b><code>max_results</code></b></p>

<blockquote>
<p>Return at most this many results.</p>

<p>Unless sorting is also requested these are not guarenteed to be the closest results to the search point.</p>
</blockquote>

<p><b><code>pre_condition</code></b></p>

<blockquote>
<p>Reference to additional user-supplied code to determine whether each point should be included in the results.</p>

<p>This code is run before the distance from the search point to the result point has been calculated.</p>

<p>See below for syntax.</p>
</blockquote>

<p><b><code>post_condition</code></b></p>

<blockquote>
<p>Reference to additional user-supplied code to determine whether each point should be included in the results.</p>

<p>This code is run after the distance from the search point to the result point has been calculated.</p>

<p>See below for syntax.</p>
</blockquote>

<p><b><code>user_data</code></b></p>

<blockquote>
<p>Arbitrary user-supplied data that is passed to the condition functions.</p>

<p>This can be used to allow the function access to additional data structures.</p>

<p>See below for syntax,</p>
</blockquote>

<p><b><code>quick_results</code></b></p>

<blockquote>
<p>Return the raw preliminary results. (no result filtering is done)</p>

<p>Normally when a search is performed the raw results have their distances computed and are filtered against the search radius and the condition functions. This process can be very slow when there are large numbers of points in a result set. Specifying this option skips those steps and can make searches several orders of magnitude faster.</p>

<p>When this option is active then instead of returning a list of points the <code>Search(...)</code> method will return a list of lists of points (some of which may be <code>undef</code>). If a <code>radius</code> was specified then the results returned will contain all the points within that radius. Additional points outside of the search radius will likely be returned as well.</p>

<p>When iterating over the arrays be sure to check whether a list element is <code>undef</code> before trying to deference it.</p>

<p>An example of returned quick results (in scalar context); POINTs are references to different points:</p>

<p><code>[ [ POINT, POINT, POINT ], [ POINT, POINT ], undef, [ POINT, POINT ] ]</code></p>

<p>To be clear, when this option is active rough radius limiting is done but there is no filtering done, no distances are computed, and no sorting is performed.</p>

<p>See the <b>PERFORMANCE</b> section below for a discussion of this option and when to use&#160;it.</p>
</blockquote>

<p><b><code>tile_adjust</code></b></p>

<blockquote>
<p>Manual adjustment for tile size (signed integer, default is <code>0</code>)</p>

<p>Values <code>&#60; 0</code> use smaller tiles, values <code>&#62; 0</code> use larger tiles. Each increment of <code>1</code> doubles or halves the tile size used. For example, set to <code>-1</code> to use tiles half the normal size in each direction.</p>

<p>This option can be a bit counter-intuitive. Although using smaller tiles will result in fewer points that need to be checked or returned it will also lead to a larger number of tiles that need to be processed. This can slow things down under some circumstances. Similarly using larger tiles results in more points spread over fewer tiles. What adjustment (if any) will result in the highest performance is highly dependant on both the search radius and on the number and distribution of the indexed points. If you adjust this value be sure to benchmark your application using a real dataset and the parameters (both typical and worst-case) that you expect to use.</p>
</blockquote>
</blockquote>

<p><b>Return value</b></p>

<blockquote>
<p>In list context the return value is a list of references to the points found or an empty array if none were found.</p>

<p>In scalar context the return value is a reference to the aforementioned list or <code>undef</code> if no results were found.</p>

<p>If either the <code>sort_results</code> or <code>radius</code> options were specified in the search options then for each point in the results the distance in meters from it to the search point will be stored in the <code>search_result_distance</code> entry in the result point&#39;s hash. It can be retreived using e.g. <code>$meters&#160;=&#160;$$point{search_result_distance};</code></p>

<p>See above section for the results returned when the <code>quick_results</code> option is active.</p>
</blockquote>

<p><b>Using user-supplied condition functions</b></p>

<blockquote>
<p>If present, these functions are called for each potential search result. They should be idempotent* and could potentially be called multiple times for a given point. The code should return TRUE (e.g. <code>1</code>) if a potential point should be included in the results or FALSE (e.g. <code>0</code> or <code>undef</code>) if the point should be excluded. The <code>pre_condition</code> function runs before the distance to the result point has been calculated and the <code>post_condition</code> function runs after it has been calculated.</p>

<p>* Functions can set outside values provided they do not affect any values used internally by <code>Seach(...)</code> and so long as these outside values have no effect on the condition&#39;s outcome. Such behavior is, of course, frowned upon.</p>

<p>The parameters to the condition function are, in order:</p>

<blockquote>
<p><b><code>$_result_point</code></b></p>

<blockquote>
<p>Reference to the potential search result being checked</p>
</blockquote>

<p><b><code>$_search_point</code></b></p>

<blockquote>
<p>Reference to the point at the center of the search</p>

<p>For <code>SearchByBounds(...)</code> this is instead the bounding box: <code>[&#160;<i>west</i>,&#160;<i>south</i>,&#160;<i>east</i>,&#160;<i>north</i>&#160;]</code></p>
</blockquote>

<p><b><code>$user_data</code></b></p>

<blockquote>
<p>Arbitrary user-supplied data</p>
</blockquote>
</blockquote>

<p>For example, the options set in the following code allows all points in the results except for the one named &#39;Point&#160;Nada&#39;:</p>

<pre> $options{pre_condition} = 
     sub {
           my ( $_result_point, $_search_point, $user_data ) = @_;
           if ( $$_result_point{name} eq $user_data ) {
             return 0;  # Exclude result
           }
           return 1;    # Point is a valid search result
         };
 $options{user_data} = &#34;Point Nada&#34;;</pre>

<p>To exclude the search point from the search results use:</p>

<pre> $options{post_condition} = 
     sub {
           my ( $_result_point, $_search_point, $user_data ) = @_;
           return ( $_result_point != $_search_point );
         };</pre>

<p>or more concisely</p>

<pre> $options{post_condition} = sub { return $_[0] != $_[1]; };</pre>

<p>In general, <code>post_condition</code> functions should be preferred since the overhead of the Perl function call is typically larger than that of the distance calculation. By checking the distance first, running the <code>post_condition</code> function might not be neccesary.</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="SearchByBounds(_..._)"
>SearchByBounds( ... )</a></h2>

<blockquote>
<p><code>@results = $index-&#62;SearchByBounds( \@bounds, \%options );</code></p>

<p><code>@results = $index-&#62;SearchByBounds( \%bounds, \%options );</code></p>

<p><code>$results_ref = $index-&#62;SearchByBounds( \@bounds, \%options );</code></p>

<p><code>$results_ref = $index-&#62;SearchByBounds( \%bounds, \%options );</code></p>

<p>Search index for points within a given bounding box</p>

<p>The points returned are those that lie between the specified latitudes and longitudes. The four corners form a rectangle only when using certain map projections such as equirectangular or mercator (including pseudo-mercator a.k.a. web mercator as used by slippy maps). If you are using a projection that does not have horizontal lines of latitude and vertical lines of longitude and you want the results to lie within and/or fill a rectangle on your map then your code will need to perform the appropriate bounds adjustment and point filtering itself.</p>

<p><b><code>@bounds</code></b> or <b><code>%bounds</code></b></p>

<blockquote>
<p>The search boundaries</p>

<p>This can be specified either as a list or a hash. Any of the following are acceptable:</p>

<blockquote>
<p><code>( <i>w_val</i>, <i>s_val</i>, <i>e_val</i>, <i>n_val</i> )</code></p>

<p><code>( &#39;south&#39; =&#62; <i>s_val</i>, &#39;north&#39; =&#62; <i>n_val</i>, &#39;west&#39; =&#62; <i>w_val</i>, &#39;east&#39; =&#62; <i>e_val</i> )</code></p>

<p><code>( &#39;s&#39; =&#62; <i>s_val</i>, &#39;n&#39; =&#62; <i>n_val</i>, &#39;w&#39; =&#62; <i>w_val</i>, &#39;e&#39; =&#62; <i>e_val</i> )</code></p>

<p><code>( &#39;S&#39; =&#62; <i>s_val</i>, &#39;N&#39; =&#62; <i>n_val</i>, &#39;W&#39; =&#62; <i>w_val</i>, &#39;E&#39; =&#62; <i>e_val</i> )</code></p>
</blockquote>

<p><code><i>s_val</i></code> and <code><i>n_val</i></code> are the south and north latitudes of the bounding box and <code><i>w_val</i></code> and <code><i>e_val</i></code> are its west and east longitudes (all values are in degrees). For the list form the order matches that used by PostGIS, shapefiles, and GeoJSON but be aware that the order of the fields is not standardized.</p>
</blockquote>

<p><b><code>%options</code></b></p>

<blockquote>
<p>The parameters for the search (all are optional):</p>

<p>Note that none of the below options have any effect when <code>quick_results</code> is specified.</p>

<blockquote>
<p><b><code>max_results</code></b></p>

<blockquote>
<p>Return at most this many results.</p>
</blockquote>

<p><b><code>condition</code></b></p>

<blockquote>
<p>Reference to additional user-supplied code to determine whether each point should be included in the results.</p>

<p>Note that unlike with the other search methods there is only a single condition function. Instead of the <code>$_search_point</code>, the second parameter to the condition function is a reference to the bounding box in list form (as described above for <code>@bounds</code>). Lastly, since &#34;distance from search point&#34; makes no sense in the context of a bounding box, none is provided to the function.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>

<p><b><code>user_data</code></b></p>

<blockquote>
<p>Arbitrary user-supplied data that is passed to the condition function.</p>

<p>This can be used to allow the function access to additional data structures.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>

<p><b><code>quick_results</code></b></p>

<blockquote>
<p>Return the raw preliminary results. (no result filtering is done)</p>

<p>Normally when a search is performed the raw results are filtered to ensure that they lie within the bounds and the condition function is applied to each result point. This process can be slow when there are large numbers of points in a result set. Specifying this option skips those steps and can make searches faster.</p>

<p>When this option is active then instead of returning a list of points the <code>SearchByBounds(...)</code> method will return a list of lists of points (some of which may be <code>undef</code>). The results are guaranteed to contain all points within the requested bounds but additional points outside of the requested bounds will likely be returned as well.</p>

<p>When iterating over the arrays be sure to check whether a list element is <code>undef</code> before trying to deference it.</p>

<p>An example of returned quick results (in scalar context); POINTs are references to different points:</p>

<p><code>[ [ POINT, POINT, POINT ], [ POINT, POINT ], undef, [ POINT, POINT ] ]</code></p>

<p>To be clear, when this option is active rough bounds limiting is done but there is no filtering done and no bound checks are actually performed.</p>

<p>See the <b>PERFORMANCE</b> section below for a discussion of this option and when to use&#160;it.</p>
</blockquote>

<p><b><code>tile_adjust</code></b></p>

<blockquote>
<p>Manual adjustment for tile size (signed integer, default is <code>0</code>)</p>

<p>Values <code>&#60; 0</code> use smaller tiles, values <code>&#62; 0</code> use larger tiles. Each increment of <code>1</code> doubles or halves the tile size used. For example, set to <code>-1</code> to use tiles half the normal size in each direction.</p>

<p>This option can be a bit counter-intuitive. Although using smaller tiles will result in fewer points that need to be checked or returned it will also lead to a larger number of tiles that need to be processed. This can slow things down under some circumstances. Similarly using larger tiles results in more points spread over fewer tiles. What adjustment (if any) will result in the highest performance is highly dependant on both the search radius and on the number and distribution of the indexed points. If you adjust this value be sure to benchmark your application using a real dataset and the parameters (both typical and worst-case) that you expect to use.</p>
</blockquote>
</blockquote>

<p><b>Return value</b></p>

<blockquote>
<p>In list context the return value is a list of references to the points found or an empty array if none were found.</p>

<p>In scalar context the return value is a reference to the aforementioned list or <code>undef</code> if no results were found.</p>

<p>See above section for the results returned when the <code>quick_results</code> option is active.</p>
</blockquote>
</blockquote>
</blockquote>

<h2><a class='u'
name="Closest(_..._)"
>Closest( ... )</a></h2>

<blockquote>
<p><code>@results = $index-&#62;Closest( \%point, $number_of_points_desired, \%options );</code></p>

<p><code>$results_ref = $index-&#62;Closest( \%point, $number_of_points_desired, \%options );</code></p>

<p>Find the point or points closest to a given point</p>

<p>Note that if you want to find the closest points within a given radius it may be faster to use <code>Search(...)</code> instead. See the <b>PERFORMANCE</b> section for more details.</p>

<p><b><code>%point</code></b></p>

<blockquote>
<p>The point to search near</p>

<p>This is either a reference to a hash containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or a reference to an array giving the point. See the <b>POINTS</b> section above for details.</p>
</blockquote>

<p><b><code>$number_of_points_desired</code></b></p>

<blockquote>
<p>The number of points that should be returned.</p>

<p>Set to <code>0</code> to not restrict the number of points returned or set it &#62;&#160;<code>0</code> to set the maximum number of points to return.</p>

<p>If omitted then this will default to <code>1</code>.</p>
</blockquote>

<p><b><code>%options</code></b></p>

<blockquote>
<p>The parameters for the search (all are optional):</p>

<p><b><code>radius</code></b></p>

<blockquote>
<p>Only return results within this distance (in meters) from search point.</p>

<p>If no <code>radius</code> is specified or the <code>radius</code> is set to <code>Geo::Index::ALL</code> then all points in the index may potentially be returned.</p>
</blockquote>

<p><b><code>sort_results</code></b></p>

<blockquote>
<p>Sort results by distance from point</p>

<p>By default points returned are sorted by distance. Set this to <code>0</code> to not sort the returned points.</p>

<p>Although sorting is not mandatory, performing it is strongly recommended since otherwise the set of points returned are not guaranteed to be the closest.</p>
</blockquote>

<p><b><code>pre_condition</code></b></p>

<blockquote>
<p>Reference to additional user-supplied code to determine whether each point should be included in the results.</p>

<p>This code is run before the distance from the search point to the result point has been calculated.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>

<p><b><code>post_condition</code></b></p>

<blockquote>
<p>Reference to additional user-supplied code to determine whether each point should be included in the results.</p>

<p>This code is run after the distance from the search point to the result point has been calculated.</p>

<p>By default, a <code>post_condition</code> function that filters out the search point is used. To remove this default function either specify a new one or set <code>post_condition</code> to &#34;<code>NONE</code>&#34;.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>

<p><b><code>user_data</code></b></p>

<blockquote>
<p>Arbitrary user-supplied data that is passed to the condition functions.</p>

<p>This can be used to allow the function access to additional data structures.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>
</blockquote>

<p><b>Return value</b></p>

<blockquote>
<p>In list context the return value is a list of references to the points found or an empty array if none were found.</p>

<p>In scalar context the return value is a reference to the aforementioned list or <code>undef</code> if no results were found.</p>

<p>For each point in the results the distance in meters from it to the search point will be stored in the <code>search_result_distance</code> entry in the result point&#39;s hash. It can be retreived using e.g. <code>$meters&#160;=&#160;$$point{search_result_distance};</code></p>
</blockquote>
</blockquote>

<h2><a class='u'
name="Farthest(_..._)"
>Farthest( ... )</a></h2>

<blockquote>
<p><code>@results = $index-&#62;Farthest( \%point, $number_of_points_desired, \%options );</code></p>

<p><code>$results_ref = $index-&#62;Farthest( \%point, $number_of_points_desired, \%options );</code></p>

<p>Find the point or points farthest from a given point</p>

<p>In other words, find the points closest to a given point&#39;s antipode.</p>

<p><b><code>%point</code></b></p>

<blockquote>
<p>The point to search relative to</p>

<p>This is either a reference to a hash containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or a reference to an array giving the point. See the <b>POINTS</b> section above for details.</p>
</blockquote>

<p><b><code>$number_of_points_desired</code></b></p>

<blockquote>
<p>The number of points that should be returned.</p>

<p>Set to <code>0</code> to not restrict the number of points returned or set it &#62;<code>0</code> to set the maximum number of points to return.</p>

<p>If omitted then this will default to <code>1</code>.</p>
</blockquote>

<p><b><code>%options</code></b></p>

<blockquote>
<p>The parameters for the search (all are optional):</p>

<p><b><code>radius</code></b></p>

<blockquote>
<p>Only return results within this distance (in meters) from search point.</p>

<p>If no <code>radius</code> is specified or the <code>radius</code> is set to <code>Geo::Index::ALL</code> then all points in the index may potentially be returned.</p>
</blockquote>

<p><b><code>sort_results</code></b></p>

<blockquote>
<p>Sort results by distance from point</p>

<p>By default points returned are sorted by distance. Set this to <code>0</code> to not sort the returned points.</p>

<p>Although sorting is not mandatory, performing it is strongly recommended since otherwise the set of points returned are not guaranteed to be the farthest.</p>
</blockquote>

<p><b><code>pre_condition</code></b></p>

<blockquote>
<p>Reference to additional user-supplied code to determine whether each point should be included in the results.</p>

<p>This code is run before the distance from the search point to the result point has been calculated.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>

<p><b><code>post_condition</code></b></p>

<blockquote>
<p>Reference to additional user-supplied code to determine whether each point should be included in the results.</p>

<p>This code is run after the distance from the search point to the result point has been calculated.</p>

<p>By default, a <code>post_condition</code> function that filters out the search point is used. To remove this default function either specify a new one, set a value for <code>user_data</code>, or set <code>post_condition</code> to &#34;<code>NONE</code>&#34;.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>

<p><b><code>user_data</code></b></p>

<blockquote>
<p>Arbitrary user-supplied data that is passed to the condition functions.</p>

<p>This can be used to allow the function access to additional data structures.</p>

<p>If the default <code>post_condition</code> is active and no <code>user_data</code> value has been provided by the caller then this is set to the actual (non-antipodal) search point.</p>

<p>See <b>Using user-supplied condition functions</b> above for syntax.</p>
</blockquote>
</blockquote>

<p><b>Return value</b></p>

<blockquote>
<p>In list context the return value is a list of references to the points found or an empty array if none were found.</p>

<p>In scalar context the return value is a reference to the aforementioned list or <code>undef</code> if no results were found.</p>

<p>For each point in the results the distance in meters from it to the search point will be stored in the <code>search_result_distance</code> entry in the result point&#39;s hash. In addition, the distance from a result point to the search point&#39;s antipode will be stored in the <code>antipode_distance</code> entry. These can be retreived using e.g.:</p>

<pre>  $meters_from_search_point  = $$point{search_result_distance};
  $meters_to_antipodal_point = $$point{antipode_distance};</pre>
</blockquote>
</blockquote>

<h2><a class='u'
name="Distance(_..._)"
>Distance( ... )</a></h2>

<blockquote>
<p><code>$meters = $index-&#62;Distance( \%point_1, \%point_2 );</code></p>

<p><code>$meters = $index-&#62;Distance( \@point_1, \@point_2 );</code></p>

<p><code>$meters = $index-&#62;Distance( \%point_1, \@point_2 );</code></p>

<p><code>$meters = $index-&#62;Distance( \@point_1, \%point_2 );</code></p>

<p>Returns the distance in meters between two points</p>

<p>The haversine function is used to compute the distance. As this assumes a spherical body the distances returned may show errors. Using the default options, these errors are up to 0.056% (north - south) or 1.12% (east - west). Such errors typically start becoming significant at distances over 20&#160;km.</p>

<p><b><code>%point_1</code></b> or <b><code>@point_1</code></b>, <b><code>%point_2</code></b> or <b><code>@point_2</code></b></p>

<blockquote>
<p>The points to measure the distance between</p>

<p>These can be either hashes containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or arrays giving each point. See the <b>POINTS</b> section above for details.</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="DistanceFrom(_..._)"
>DistanceFrom( ... )</a></h2>

<blockquote>
<p><code>$meters = $index-&#62;DistanceFrom( \%point_1 );</code></p>

<p><code>$meters = $index-&#62;DistanceFrom( \@point_1 );</code></p>

<p>Set an initial point to measure distances from</p>

<p>Note that any call to <code>Distance(...)</code> and some calls to <code>Search(...)</code> (those using the <code>radius</code> or <code>sort_results</code> options) will overwrite the initial point set with this method.</p>

<p><b><code>%point_1</code></b> or <b><code>@point_1</code></b></p>

<blockquote>
<p>The point to measure distances from</p>

<p>This can be either a hash containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or an array giving the point. See the <b>POINTS</b> section above for details.</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="DistanceTo(_..._)"
>DistanceTo( ... )</a></h2>

<blockquote>
<p><code>$meters = $index-&#62;DistanceTo( \%point_2 );</code></p>

<p><code>$meters = $index-&#62;DistanceTo( \@point_2 );</code></p>

<p>Returns the distance in meters between the specified point and the one set earlier with <code>DistanceFrom(...)</code>.</p>

<p>The haversine function is used to compute the distance. As this assumes a spherical body the distances returned may show errors. Using the default options, these errors are up to 0.056% (north - south) or 1.12% (east - west). Such errors typically start becoming significant at distances over 20&#160;km.</p>

<p><b><code>%point_2</code></b> or <b><code>@point_2</code></b></p>

<blockquote>
<p>The point to measure distances to</p>

<p>This can be either a hash containing at a minimum a <code>lat</code> and a <code>lon</code> value (both in degrees) or an array giving the point. See the <b>POINTS</b> section above for details.</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="GetConfiguration(_)"
>GetConfiguration( )</a></h2>

<blockquote>
<p><code>%configuation = $index-&#62;GetConfiguration( );</code></p>

<p>Returns the running configuration of the Geo::Index object.</p>

<p>The return value is a hash with the following entries:</p>

<blockquote>
<p><code>key_type</code> - The key type in use:</p>

<blockquote>
<p>&#39;<code>text</code>&#39; for text keys (e.g. &#39;<code>12:345,6789</code>&#39;)</p>

<p>&#39;<code>numeric</code>&#39; for 64-bit numeric keys</p>

<p>&#39;<code>packed</code>&#39; for 64-bit numeric keys packed into an 8-byte string</p>
</blockquote>

<p><code>code_type</code> - The type of backend code in use:</p>

<blockquote>
<p>&#39;<code>perl</code>&#39; for Perl functions</p>

<p>&#39;<code>float</code>&#39; for C functions mostly using <code>float</code> values.</p>

<p>&#39;<code>double</code>&#39; for C functions mostly using <code>double</code> values.</p>
</blockquote>

<p><code>levels</code> - Number of levels in index (excluding the global level)</p>

<p><code>planetary_radius</code> - Average planetary radius (in meters)</p>

<p><code>polar_circumference</code> - Polar circumference (in meters)</p>

<p><code>equatorial_circumference</code> - Equatorial circumference (in meters)</p>

<p><code>size</code> - Number of points currently indexed</p>
</blockquote>
</blockquote>

<h2><a class='u'
name="GetStatistics(_)"
>GetStatistics( )</a></h2>

<blockquote>
<p><code>@stats = $index-&#62;GetStatistics( );</code></p>

<p>Returns statistics regarding the Geo::Index object.</p>

<p>The return value is a list with one entry per level. Each list entry is a hash reference giving statistics for a single level of the index and contains the following entries:</p>

<blockquote>
<p><code>level</code> - The level number the statistics are for</p>

<p><code>points</code> - Total number of points indexed in this level</p>

<p><code>tiles</code> - Number of tiles containing at least one point</p>

<p><code>min_tile_points</code> - Minimum number of points in a non-empty tile</p>

<p><code>max_tile_points</code> - Maximum number of points in a non-empty tile</p>

<p><code>avg_tile_points</code> - Average number of points in a non-empty tile</p>
</blockquote>
</blockquote>

<h1><a class='u'
name="PERFORMANCE"
>PERFORMANCE</a></h1>

<h2><a class='u'
name="Overview"
>Overview</a></h2>

<p>Geo::Index is intended for stand-alone applications that need a way to quickly perform proximity seaches on relatively small datasets (at most a few million points). Typical search speeds are three to five orders of magnitude faster than a linear search. For larger datasets and for applications running in a server environment using something like PostGIS is more appropriate.</p>

<p>Indexing speed is about 50,000 points per second when <code>levels</code> is 20. Search speeds are highly dependant on the data indexed and on search parameters but are typically in the neighborhood of a few thousand searches per second.</p>

<p>Memory usage tends to be rather high; for 1,000,000 points the index is ~3.2&#160;GB for tightly clustered points or ~4.6&#160;GB when spread evenly world-wide. The size of an index grows linearly with each added point at a rate of about 4&#160;kB per point. When a point is first encountered whilst searching its size will increase by about 100 bytes (this only happens once per point).</p>

<p>Since performance is so dependant on data and usage, the the user is encouraged to test all available options while developing their application before choosing the one that works fastest. The <code>examples/benchmark.pl</code> script included with this module may be helpful for measuring this module&#39;s performance.</p>

<h2><a class='u'
name="General_tips"
>General tips</a></h2>

<p>Here are some guidelines for best results:</p>

<ul>
<li><b>Requesting results as a list reference is faster than asking for a plain list.</b>
<p>That is, e.g., <code>$results&#160;=&#160;Search(...);</code> is faster than <code>@results = Search(...);</code></p>
</li>

<li><b>Post-conditions are faster than pre-conditions.</b>
<p>Benchmarking has shown that the cost of the Perl function call is higher than that of the distance-related code.Thus there is probably no reason to use pre-conditions. Put concisely,</p>

<blockquote>
<pre> $results = $index-&#62;Search( $point, { post_condition =&#62; $code_ref } );</pre>
</blockquote>

<p>is faster than</p>

<blockquote>
<pre> $results = $index-&#62;Search( $point, { pre_condition =&#62; $code_ref } );</pre>
</blockquote>
</li>

<li><b>Choose an appropriate value for <code>levels</code> when creating the index</b>
<p>The <code>Search(...)</code> method has best performance when the size of the most detailed level of the index has a smaller physical size than the radius of a typical search. For example, if your searches are typically for points within 100 meters then an index with <code>levels</code> should be set to at least 18 (~75 meters at the equator) to yield best results; if typical searches have 10 meter radius then <code>levels</code> should be 22.</p>

<p>The <code>Closest(...)</code> method works best when the most detailed level of the index contains a single point per tile and search points lie close to potential result points.</p>

<p>To help tune the <code>levels</code> value, the <code>GetConfiguration(...)</code> method can be used to find out the physical size of the most detailed level along with statistics on the number of points per index tile.</p>
</li>

<li><b>Use the <code>quick_results</code> option when possible.</b>
<p>Filtering points and combining them into a single, flat list can be very expensive. Many applications can tolerate getting additional points beyond those matching the search criteria. An example of this is drawing points on a map; if points are clipped to the visible area when they are drawn it may not matter if some of them lie outside of it.</p>
</li>

<li><b>Use <code>Search(...)</code> instead of <code>Closest(...)</code> when you have a search radius.</b>
<p>The <code>Closest(...)</code> function is most efficient when no search radius is specified or when result points lie very close to the search point. Closeness is relative to the tile size of the most detailed index level; for the default index depth (<code>20</code>), &#34;very close&#34; is roughly within about 100 meters.</p>

<p>When clipping results to a maximal radius it is typically much faster to use <code>Search(...)</code> with the <code>sort_results</code> and <code>max_results</code> options*.</p>

<p>For example, to find the closest <code>$n</code> points within distance <code>$d</code> of a point <code>$p</code> it is usually much faster to use</p>

<blockquote>
<pre> %options = (
              max_results    =&#62; $n, 
              radius         =&#62; $d, 
              sort_results   =&#62; 1,
              post_condition =&#62; sub { return $_[0] != $_[1]; }
            );
 $results = $index-&#62;Search( $p, \%options );</pre>
</blockquote>

<p>instead of</p>

<blockquote>
<pre> $results = $index-&#62;Closest( $p, $n { radius =&#62; $d } );</pre>
</blockquote>

<p>* The <code>post_condition</code> shown in the example omits the search point from the results and is needed to fully emulate the behavior of <code>Closest(...)</code>.</p>
</li>
</ul>

<h2><a class='u'
name="Technical_discussion"
>Technical discussion</a></h2>

<p>Both <code>Search(...)</code> and <code>SearchByBounds(...)</code> are very fast since they can find the relevant index tiles in linear time. Since the time needed to filter the results is directly proportional to the number of points retreived from the index, best performance occurs when the size of the most detailed tiles is smaller than that of the typical search radius or search bounds.</p>

<p>Searches run using <code>Closest(...)</code> are done starting from the most detailed level and work upwards. Best performance occurs when a result is found in the first few iterations. If the first iteration that finds points yields a large number of points then performance will suffer since the distance to each of these points will need to be measured to find the closest. For similar reasons, requesting a large number of closest points in a single call will also impact performance. The <code>Farthest(...)</code> method is largely a wrapper for <code>Closest(...)</code> and thus exhibits similar behavior.</p>

<p>Some functions within Geo::Index have optional implimentations written in C. If these are active (by default they are whenever possible) searches typically run 25% to 50% faster.</p>

<p>Whenever possible Geo::Index uses numeric index keys. Compared to text index keys, numeric keys improve performance with about 30% faster speed and about 50% smaller index memory usage. The downside to numeric keys is that they are less legible to humans while debugging. (Whether numeric or text keys are used can be changed by setting the appropriate value at the top of <code>Geo/Index.pm</code>)</p>

<h2><a class='u'
name="Benchmark_results"
>Benchmark results</a></h2>

<p>Typical benchmark results run on a modern workstation using numeric keys and double-precision C low-level code are as follows:</p>

<ul>
<li><b><code>IndexPoints(...)</code></b>
<p>Points can be added to an index at the rate of about 50,000 per second.</p>
</li>

<li><b><code>Search(...)</code></b>
<p>Typical searches returning values run at about 25,000 to 50,000 searches per second. Worst-case performance is under 50 searches per second and searches returning no results run at over 100,000 searches per second. The overhead of traversing the results is fairly negligable.</p>

<p>Quick searches run at 120,000 to 150,000 searches per second. Actually doing anything with the results slows things down a lot. Including traversal of the results, a typical quick search runs at 40,000 to 100,000 searches per second with the worst-case being about 80 searches per second.</p>

<p>If distances to the result points are not needed, quick searches are typically about 75% faster than normal ones albeit with about 5 times as many results being returned.</p>
</li>

<li><b><code>SearchByBounds(...)</code></b>
<p>For the <code>SearchByBounds(...)</code> method run time correlates with the size of the bounding box with smaller bounding boxes typically yielding faster run times.</p>

<p>A fairly typical search yielding about 50 results runs at about 10,000 searches per second in normal mode and about 30,000 searches per second in quick mode. A nearly worst case example is a search returning 100,000 points; this will run at about 5 searches per second in normal mode or about 8000 searches per second in quick mode.</p>
</li>

<li><b><code>Closest(...)</code></b>
<p>For the Closest(...) method the highest performance is seen when there are result points close to the search point. Search speeds for the single closest point are typically in excess of 20,000 per second for close-by results or about 8,000 per second when results are far away. Worst case speeds of about 1,000 searches per second occur when all indexed points are in the hemisphere opposite the search point.</p>
</li>

<li><b><code>Farthest(...)</code></b>
<p>For the Farthest(...) method the highest performance is seen when there are result points nearly antipodal to the search point. Search speeds for the single farthest point are typically in excess of 20,000 per second when nearly-antipodal points exist. Worst case speeds of about 1,000 searches per second occur when all indexed points are in the same hemisphere as the search point.</p>
</li>
</ul>

<p>Note that the numbers above are approximate and are highly dependant on the data being searched, the type of search being run, and on the number of results returned. Actual searches may be an order of magnitude or more slower.</p>

<p>A sample benchmark run can be found in <code>examples/benchmark.txt</code> To run the benchmarks yourself you can run <code>examples/benchmark.pl</code> It needs the Devel::Size and Time::HiRes modules installed and a single run takes about 8 minutes.</p>

<p>Since Perl constants cannot be changed from the commandline you will need to edit the <code>Geo/Index.pm</code> to force the use of numeric keys, packed numeric keys, or text keys. This can be done by uncommenting the appropriate lines at the head of the file (look for <code>USE_NUMERIC_KEYS</code> and <code>USE_PACKED_KEYS</code>). When running <code>benchmark.pl</code>, the various other options can be found at the top of the script. When writing your own programs you can switch between the Perl and C single- or double-precision low-level code by using the <code>function_type</code> option when calling <code>new(...)</code>.</p>

<h2><a class='u'
name="Potential_optimizations"
>Potential optimizations</a></h2>

<p>The high cost of constructing and traversing the results seems inherent to the Perl language and there does not seem to be any way to avoid it. The is some potential for optimization though:</p>

<ul>
<li>The <code>pre_condition</code> and <code>post_condition</code> function calls might be sped up by assigning them to function handles (much as is done with <code>HaversineDistance</code>, etc.) instead of making the calls by dereferencing the variables.</li>

<li>Performance could potentially be improved by splitting the current combined index into individual indices for each level. Having smaller keys and indices should result in higher performance but the additional layer of indirection could slow things down in some circumstances.</li>

<li>Improvements might be possible to the performance of <code>Closest( <i>n</i>, ...)</code> where <code><i>n</i></code>&#62;1 and per-point distances are not needed by the caller. At each iteration of the algorithm the previously-used search radius gives the maximal distance to all points already found, obviating the need to calculate every point&#39;s distance. Only points in the final level of the search would need to have their distances calculated. The downside to this method is that the point distances would not be available for all points in a result set (only for those found in the final search level).</li>

<li>A number of alternative datastructures were explored for the point index but benchmarking showed plain Perl hashes to be by far the most efficient. It is possible, though in my opinion unlikely, that a faster data structure choice exists that is suitable for use in this module.</li>
</ul>

<h1><a class='u'
name="THEORY_OF_OPERATION"
>THEORY OF OPERATION</a></h1>

<h2><a class='u'
name="Overview"
>Overview</a></h2>

<p>A given index comprises sets of tiles at various zoom levels with each tile containing a list of the points that lie within it. The lowest level of the index covers the entire globe. Each higher index level contains twice as many tiles in each direction. At each zoom level points are linearly mapped to grid tiles based on their latitudes and longitudes using an equirectangular projection. This is fairly analagous to how typical web slippy maps are organized (though they use a pseudo-mercator projection).</p>

<p>As one approaches the poles the tiles become increasingly distorted with the area (in square meters) covered by each tile becoming progressively smaller. The distance in meters for one degree of longitude gets smaller as one moves away from the equator. The distance in meters for one degree of latitude, however, remains constant at all latitudes.</p>

<p>Each tile has a name that gives its zoom level and position. These names are used as keys into a Perl hash allowing the quick retrieval of the points that lie within a given tile. The various search methods are designed to efficiently pull points from this index and filter them in various ways. The format used for the keys is described in the <b>Tile naming</b> section below.</p>

<p>Additional datastructures (e.g. the list of all points in the index) are also present but knowing their details is not needed to understand how the index functions. In the descriptions below, some minor (but often critical) details have been omitted and some simplifications have been made; these details (mainly edge cases) are discussed in the code comments.</p>

<h2><a class='u'
name="Populating_the_index"
>Populating the index</a></h2>

<p>When a point is added to the index it is stored multiple times in the index hash, once for each level. This is done as follows:</p>

<ul>
<li>The point&#39;s latitude and longitude are converted to integers. This is done using a simple linear mapping. In pseudo-code, the equations used are:
<pre> max_size = 2**(levels - 1)
 
 integer_latitude  = floor( ( latitude + 90.0 )  * max_size / 180.0 )
 integer_latitude  = max_size - 1 if (integer_latitude == max_size)
 
 integer_longitude = floor( ( longitude + 180.0 ) * max_size / 360.0 ) % max_size</pre>

<p>The values for <code>latitude</code> and <code>longitude</code> are in degrees and <code>levels</code> is the number of levels in the index (not counting the global&#160;one).</p>
</li>

<li>Each index level is looped through from the index&#39;s maximum level to <code>0</code>. At each level, the key (comprised of <code>level</code>, <code>integer_latitide</code>, and <code>integer_longitide</code>, see also below) is used to retrieve the corresponding value from the index hash. This value is a reference to the list of points that lie within the grid tile named by the key. The point being indexed is added to the retreived list. If there is no list stored in the index for the current key then a new list is created and added. As a special case, all points adjacent to the poles (that is points with integer latitudes of <code>0</code> or <code>max_size - 1</code>) use the longitude <code>ALL</code> in their keys.
<p>Once the point has been added, the integer latitudes and longitudes as well as the <code>max_size</code> are shifted right by one bit in preparation for the the next level.</p>
</li>

<li>Once a the point has been added to the index at each level, the point is added to the global index entry using the key <code>ALL</code>,&#160;<code>ALL</code>,&#160;<code>ALL</code>. (All indexed points can be found under this key.)</li>
</ul>

<h2><a class='u'
name="Basic_searching"
>Basic searching</a></h2>

<p>The <code>Search(...)</code> method is typically used to find all points lying within a given radius of a search point. Two steps are performed by this method: retrieval of preliminary results and filtering of the results based on the search criteria.</p>

<p>If no search radius was specfied, if a global search was requested, or if the search radius covers more than half the globe then the preliminary results are all points in the index. Otherwise, the preliminary results are gathered as follows:</p>

<p>The appropriate tile zoom level to use is determined using:</p>

<pre> shift = ceil( log2( search_radius / half_circumference ) )
 level = max_level - shift</pre>

<p>This results in the smallest level that could potentially contain all result points within a single tile.</p>

<p>The search radius (in meters) is converted to two search angular radii, one for latitude and one for longitude. This is done since the number of meters per degree longitude decreases as one approaches the poles. Thus the north-south (latitude) search radius remains constant at all latitudes but the east-west (longitude) search radius increases as one nears the poles.</p>

<p>Each extreme is converted to an integer and shifted right by the determined <code>shift</code>, The preliminary results are retrieved from the index by iterating over the keys for the computed level, bounded by the integer extrema. This typically, but not always, results in a list of pointers to four tiles&#39; points.</p>

<p>If the <code>quick_results</code> option is active then this preliminary list of lists of points is returned. If not then the points are filtered to only include those matching the search criteria. The filtered points are optionally sorted and then returned. Note that when large numbers of points have been found this filtering can be very slow; see <b>PERFORMANCE</b> above for details.</p>

<h2><a class='u'
name="Proximity_searching"
>Proximity searching</a></h2>

<p>The <code>Closest(...)</code> and <code>Farthest(...)</code> methods find the points closest to (or farthest from) a search point. The <code>Closest(...)</code> method works as follows:</p>

<p>The search starts at the most detailed level of the index and proceeds to the least detailed (<code>0</code>). At each level, the grid tile that the search point lies in along with the three closest grid squares are identified. The method used for selecting the adjacent tiles is to look at the least-significant bits of the integer position at the previous (more detailed) level. A <code>1</code> bit for the latitude selects tiles to the north, a <code>0</code> bit the ones to the south. Likewise a <code>1</code> for the longitude selects the ones east and a <code>0</code> the ones west.</p>

<p>Now that the four tiles have been identified, the largest radius from the search point to the tile edges is determined. The distance from the search point to each point within the four tiles is measured. If the point is within the radius computed and it passes any pre- or post-condition tests it is added to the results list. To speed up processing, points that have already been rejected along with the distances so far measured are cached. As a convenience, by default a filter is applied that omits the search point from the results.</p>

<p>Once all points within a level&#39;s four chosen tiles have been gathered a check is done to see whether at least the requested number of points have been found. If they have then the loop ends, if not then the next (less-detailed) level is processed.</p>

<p>By default, the results are then sorted by distance which ensures that the closest results are earliest in the list. This is necessary since although the nature of the algorithm tends to place closer points earlier in the results there is no inherent order to the points added from a particular index level. Lastly, the requested number of result points is returned.</p>

<p>The <code>Farthest(...)</code> method is largely implemented as a wrapper for <code>Closest(...)</code>. It functions by finding the closest points to the search point&#39;s antipode.</p>

<h2><a class='u'
name="Searching_by_bounding_box"
>Searching by bounding box</a></h2>

<p>The <code>SearchByBounds(...)</code> method works much the same as <code>Search(...)</code> method. Instead of computing extrema of a search circle, those of the supplied bounding box are used. The tile level used is <code>max( latitude_level, longitude_level )</code> where <code>latitude_level</code> and <code>longitude_level</code> are the most detailed levels that could potentially (given their extrema&#39;s angular distances) contain their respective extrema within a single tile in each direction. The remainder of the method is identical to that of <code>Search(...)</code> albeit with all distance-related code removed.</p>

<h2><a class='u'
name="Tile_naming_(key_generation)"
>Tile naming (key generation)</a></h2>

<p>As mentioned earlier, keys consist of a zoom level, a latitude, and a longitude. Each key uniquely names a given tile.</p>

<p>Zoom levels are either integers between <code>0</code> and the maximum zoom level or the special zoom level <code>ALL</code> (with the value <code>-1</code>) that covers the entire globe. Latitudes and longitudes are integers between <code>0</code> and one less than the maximum grid size for the level. The tiles immediately adjacent to the poles are treated differently. In these areas the coverage of each tile is quite small and the algorithm around the poles would normally be complex. To accomodate these issues, the special value <code>ALL</code> (with the value <code>-1</code>) is used for the longitude of the polar tiles (those areas with the lowest or highest latitude value for the key&#39;s level). All points lying in a polar region are assigned to that region&#39;s overarching <code>ALL</code> tile. At the global level all three components are set to <code>ALL</code>.</p>

<p>If Perl has been compiled with 64-bit support then each key is packed into a 64 bit integer. The level is stored in the upper 6 bits (bits 58 .. 63), the integer latitude in the next 29 bits (bits 29 .. 57), and the integer longitude in the low 29 bits (bits 0 .. 28). To represent the <code>ALL</code> value all bits in the relavent field are set to <code>1</code>. Note that even on 32-bit systems Perl is often compiled with 64-bit support.</p>

<p>If Perl does not have 64-bit support then a different format is used. In most places within Geo::Index, keys are stored as three-element array references. The first field contains the level, the second the integer latitude and the third the integer longitude. If present, <code>ALL</code> values are stored as-is as their integer value (<code>-1</code>). For accessing the index, keys are converted to strings with the format &#34;<i>level</i><code>:</code><i>latitude</i><code>,</code><i>longitude</i>&#34; with the literal string &#34;<code>ALL</code>&#34; being used for <code>ALL</code> values.</p>

<h2><a class='u'
name="Object_structure"
>Object structure</a></h2>

<p>Each index object is a hash containing a number of entries These are:</p>

<blockquote>
<p><b><code>$self-&#62;{index}</code></b> - The points index</p>

<p>Entry is a hash reference. Keys are tile names (as discussed above), values are lists of point references.</p>

<p><b><code>$self-&#62;{indices}</code></b> - Indices used for each point</p>

<p>Entry is a hash reference. Keys are point references, values are lists of tile names.</p>

<p><b><code>$self-&#62;{positions}</code></b> - Each point&#39;s position when indexed</p>

<p>Entry is a hash reference. Keys are point references, values are two-element lists giving each point&#39;s latitude and longitude at the time it was indexed.</p>

<p><b><code>$self-&#62;{levels}</code></b> - Number of levels in the index (excluding the global level)</p>

<p><b><code>$self-&#62;{planetary_radius}</code></b> - The planetary radius used by the index (in meters)</p>

<p><b><code>$self-&#62;{polar_circumference}</code></b> - The polar circumference used by the index (in meters)</p>

<p><b><code>$self-&#62;{equatorial_circumference}</code></b> - The equatorial circumference used by the index (in meters)</p>
</blockquote>

<h1><a class='u'
name="BUGS_AND_DEFICIENCIES"
>BUGS AND DEFICIENCIES</a></h1>

<h3><a class='u'
name="Known_issues"
>Known issues</a></h3>

<ul>
<li>This module is not believed to be thread-safe. In specific:
<ul>
<li>The <code>SetUpDistance(...)</code> function stores the first point&#39;s position in global variables.
<p>To fix this, <code>DistanceFrom*(...)</code> and <code>DistanceTo*(...)</code> would need to be removed plus <code>SetUpDistance*(...)</code> and <code>HaversineDistance*(...)</code> would need to be combined into a single 4-argument <code>HaversineDistance*(...)</code> function. Calling code would need to be modified as appropriate. In terms of performance, the overall cost of doing this is likely quite low.</p>
</li>

<li>The search code stores distances computed for a specific search into the point datastructures. If multiple concurrent searches are run against a single index then distances computed by one search may overwrite those from another search. This can lead to inconsistent results.
<p>To fix this a per-search distance hash would need to be maintained. This could have serious performance implications and would preclude returning the point distances within the point hashes. The distances could, however, be returned in an additional datastructure.</p>
</li>

<li>Adding and deleting points to/from the index is not atomic. Running e.g. a search while points are being added or deleted can lead to unpredictable behavior (up to and including the program crashing).
<p>One could fix this by adding object-level locks:</p>

<ul>
<li>Block concurrent calls to the <code>Index(...)</code> and <code>DeletePointIndex(...)</code>methods</li>

<li>Block calls to the <code>Index(...)</code> and <code>DeletePointIndex(...)</code> methods while searches are running</li>

<li>Block calls to <code>Search(...)</code> <i>et al.</i> when the <code>Index(...)</code> or <code>DeletePointIndex(...)</code> methods are active</li>
</ul>
</li>
</ul>
</li>
</ul>

<ul>
<li>Including the same point in multiple indices or searches at the same time could lead to interesting results.
<p>As mentioned above, this is due to the storage of search result distances within the points and not within the index object. Each search that involves a given point will likely overwrite its <code>search_result_distance</code> value.</p>

<p>This could be encountered in a number of ways. For example, a search using a condition function that itself runs a search against the second index could be problematic. This could be encountered even when using a single index. For example, if code relies on the distances values from a search it should save a copy of them before running subsearches against the same set of points. If this is not done then the distance values from the first search may be overwritten by those of the subsequent searches.</p>
</li>

<li>Geo::Index uses the spherical haversine formula to compute distances. While quite fast, its accuracy over long distances is poor, with a worst case error of about 0.1% (22 km). Since the module already has provision for changing the backends used for the distance methods, adding a new backend to, for example, compute accurate distances on e.g. a WGS-84 spheroid would be simple and straight-forward.</li>

<li>In places the code can be repetitious or awkward in style. This was done because, especially in the inner loops, speed has been favoured over clarity.</li>
</ul>

<h3><a class='u'
name="Reporting_bugs"
>Reporting bugs</a></h3>

<p>Please submit any bugs or feature requests either to <code>bug-geo-index at rt.cpan.org</code> or through the web interface at <a href="http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Geo-Index" class="podlinkurl"
>http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Geo-Index</a>. I will receive notification when you do and you will be automatically notified of progress on your submission as it takes place.</p>

<h1><a class='u'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Alex Kent Hajnal &#160; <code>akh@cpan.org</code> &#160; <a href="https://alephnull.net/software" class="podlinkurl"
>https://alephnull.net/software</a></p>

<h1><a class='u'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 2019 Alexander Hajnal, All rights reserved</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See <a href="http://search.cpan.org/perldoc?perlartistic" class="podlinkpod"
>perlartistic</a>.</p>

<!-- end doc -->

</body></html>
